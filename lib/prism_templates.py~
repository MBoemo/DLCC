class Prism_Templates:

	def preamble(self):
		template = '''//Prism code generated automatically by Bellerophon

// Forward walk rate
const double walk_rate = 1;

ctmc

//-----------------------------------------------------'''

		return template

	def leaf_module(self,track,track_to_be_blocked):

		track = self.correct_1(track)
		track_to_be_blocked = self.correct_1(track_to_be_blocked)
		template = '''//-----------------------------------------------------

// %(module_name)s TRACK (%(module_name)sT)

// Maximum track length
const int %(track_name)s_max;// = 2;

module %(module_name)sT
	
	// States - where we are on the track
	%(track_name)s_step : [0..%(track_name)s_max] init 0;

	// Walk
	[%(track_name)s_walk] true -> walk_rate : (%(track_name)s_step'= min(%(track_name)s_step+1,%(track_name)s_max));

	// Block the next track
	[%(will_block)s_blocked] %(track_name)s_step = %(track_name)s_max -> true;
	[%(will_block)s_unblocked] %(track_name)s_step < %(track_name)s_max -> true;

endmodule

'''

		return template %dict(track_name = track,module_name = track.upper(),will_block = track_to_be_blocked)

	def single_blocked_module(self,track,blocked_by,track_to_be_blocked):

		track = self.correct_1(track)
		blocked_by = self.correct_1(blocked_by)
		track_to_be_blocked = self.correct_1(track_to_be_blocked)

		template = '''//-----------------------------------------------------

// %(module_name)s TRACK (%(module_name)sT)

// Maximum track length
const int %(track_name)s_max;

// Intersections
const int %(blocker)s_%(track_name)s_intersection;// = rt_max;

module %(module_name)sT

	// States - where we are on the track
	%(track_name)s_step : [0..%(track_name)s_max] init 0;

	// Handle blockage
	[%(track_name)s_blocked] %(track_name)s_step < %(blocker)s_%(track_name)s_intersection -> walk_rate : (%(track_name)s_step'=min(%(track_name)s_step+1,%(blocker)s_%(track_name)s_intersection));
	[%(track_name)s_blocked] %(track_name)s_step > %(blocker)s_%(track_name)s_intersection -> walk_rate : (%(track_name)s_step'=min(%(track_name)s_step+1,%(track_name)s_max));
	[%(track_name)s_unblocked] %(track_name)s_step < %(track_name)s_max -> walk_rate : (%(track_name)s_step'=min(%(track_name)s_step+1,%(track_name)s_max));

	// Block the next track
	[%(will_block)s_blocked] %(track_name)s_step = %(track_name)s_max -> true;
	[%(will_block)s_unblocked] %(track_name)s_step < %(track_name)s_max -> true;

endmodule

'''

		return template %dict(track_name = track,module_name = track.upper(),blocker = blocked_by,will_block = track_to_be_blocked)

	def double_blocked_module(self,track,first_blocked_by,second_blocked_by,track_to_be_blocked):

		track = self.correct_1(track)
		first_blocked_by = self.correct_1(first_blocked_by)
		second_blocked_by = self.correct_1(second_blocked_by)
		track_to_be_blocked = self.correct_1(track_to_be_blocked)

		template = '''//-----------------------------------------------------

// %(module_name)s TRACK (%(module_name)sT)

// Maximum track length
const int %(track_name)s_max;

// Intersections
const int %(blocker1)s_%(track_name)s_intersection;// = rt_max;
const int %(blocker1)s_%(track_name)s_intersection;// = rt_max;

module %(module_name)sT

	// States - where we are on the track
	%(track_name)s_step : [0..%(track_name)s_max] init 0;

	// Handle blockage
	[%(track_name)s_blocked] %(track_name)s_step < %(blocker)s_%(track_name)s_intersection -> walk_rate : (%(track_name)s_step'=min(%(track_name)s_step+1,%(blocker)s_%(track_name)s_intersection));
	[%(track_name)s_blocked] %(track_name)s_step > %(blocker)s_%(track_name)s_intersection -> walk_rate : (%(track_name)s_step'=min(%(track_name)s_step+1,%(track_name)s_max));
	[%(track_name)s_unblocked] %(track_name)s_step < %(track_name)s_max -> walk_rate : (%(track_name)s_step'=min(%(track_name)s_step+1,%(track_name)s_max));

	// Block the next track
	[%(will_block)s_blocked] %(track_name)s_step = %(track_name)s_max -> true;
	[%(will_block)s_unblocked] %(track_name)s_step < %(track_name)s_max -> true;

endmodule

'''

		return template %dict(track_name = track,module_name = track.upper(),blocker = blocked_by,will_block = track_to_be_blocked)

	def terminal_module(self,track,blocked_by):

		track = self.correct_1(track)
		blocked_by = self.correct_1(blocked_by)
		
		template = '''//-----------------------------------------------------

// %(module_name)s TRACK (%(module_name)sT)

// Maximum track length
const int %(track_name)s_max;

// Intersections
const int %(blocker)s_%(track_name)s_intersection;// = rt_max;

module %(module_name)sT

	// States - where we are on the track
	%(track_name)s_step : [0..%(track_name)s_max] init 0;

	// Handle blockage
	[%(track_name)s_blocked] %(track_name)s_step < %(blocker)s_%(track_name)s_intersection -> walk_rate : (%(track_name)s_step'=min(%(track_name)s_step+1,%(blocker)s_%(track_name)s_intersection));
	[%(track_name)s_blocked] %(track_name)s_step > %(blocker)s_%(track_name)s_intersection -> walk_rate : (%(track_name)s_step'=min(%(track_name)s_step+1,%(track_name)s_max));
	[%(track_name)s_unblocked] %(track_name)s_step < %(track_name)s_max -> walk_rate : (%(track_name)s_step'=min(%(track_name)s_step+1,%(track_name)s_max));

endmodule

'''
		
		return template %dict(track_name = track,module_name = track.upper(),blocker = blocked_by)
	
	def correct_1(self,track_name):
		if track_name[0] == '1':
			track_name = track_name.replace('1','ONE',1)
			return track_name
		else:
			return track_name
