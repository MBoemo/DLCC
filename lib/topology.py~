class Topology:
	
	def __init__(self):
		from sets import Set #chomp_tree needs this - define it here because chomp_tree is recursive
		self.Set = Set

		from lib.xml_input import Inputs
		self.Inputs = Inputs

		from treelib import Tree, Node
		self.Tree = Tree
		self.Node = Node

	
	def fun_gate_topology(self,tree_smallSubtree,tree_nested_logic_statement,inputs,gate,counter):
		str_gate_type = gate.translate(None,'0')
		if str_gate_type == 'Not':
			tree_smallSubtree.create_node('1_'+str(counter),'1_'+str(counter)) 
		        tree_smallSubtree.create_node(inputs[0],inputs[0],parent='1_'+str(counter))
		        counter = counter + 1
		if str_gate_type == 'Or':
			tree_smallSubtree.create_node('1_'+str(counter),'1_'+str(counter)) 
			tree_smallSubtree.create_node('1_'+str(counter+1),'1_'+str(counter+1),parent='1_'+str(counter))
		        tree_smallSubtree.create_node(inputs[0],inputs[0],parent='1_'+str(counter+1))
		        tree_smallSubtree.create_node(inputs[1],inputs[1],parent='1_'+str(counter+1))
		        counter = counter + 2
		if str_gate_type == 'And':
			tree_smallSubtree.create_node(inputs[1],inputs[1]) 
			tree_smallSubtree.create_node('1_'+str(counter),'1_'+str(counter),parent=inputs[1])
		        tree_smallSubtree.create_node(inputs[0],inputs[0],parent='1_'+str(counter))
		        counter = counter + 1
		return counter


	def fun_nested_logic_tree_2_topology_tree(self,tree_topology,tree_nested_logic_statement,int_running_label):
		tree_smallSubtree = self.Tree()	# create a small subtree - this will be the tree for the specific gate we're on generated by gate_topology
		bool_baseCase = False # the base case is the first iteration we do: when the small subtree is the root.  initialise to false
		int_running_label = self.fun_gate_topology(tree_smallSubtree,tree_nested_logic_statement,tree_nested_logic_statement.is_branch(tree_nested_logic_statement.root),tree_nested_logic_statement.root,int_running_label)	# use gate_topology to create the small subtree. it'll return our running label for unique names

		if tree_topology.root == None: # if there's nothing in tree_topology, we're at the base case (first case).  so the small subtree we generated will be the first tree
			tree_topology = tree_smallSubtree # make the subtree tree_topology
			bool_baseCase = True # flip this to true so we don't try to replace gates with the subtree
		
		for leaf in tree_topology.leaves(tree_topology.root): # look through the leaves of tree_topology to see if we still have a gate
			if leaf in ['Not','Or','And']: # if we do...
				if bool_baseCase == False: # and if it isn't the base case...
					tree_topology.paste(tree_topology.parent(leaf).identifier,tree_smallSubtree) # swap the subtree for the gate
					tree_topology.remove_node(leaf) # remove the gate node

				self.fun_nested_logic_tree_2_topology_tree(tree_topology,tree_nested_logic_statement.subtree(leaf),int_running_label) # iterate again 
			
		return tree_topology

	def refine_topology(self,tree_topology,node_start):
		leaf_bottom = node_start[0]
		node_upOne = tree_topology.parent(leaf_bottom).identifier
		node_upTwo = tree_topology.parent(tree_topology.parent(leaf_bottom).identifier).identifier
		node_upThree = tree_topology.parent(tree_topology.parent(tree_topology.parent(leaf_bottom).identifier).identifier).identifier
		if  node_upOne[0] == '1' and node_upTwo[0] == '1' and node_upThree[0] == '1': # if you have three successive 1's above the leaf...
			tree_sub_t = tree_topology.subtree(tree_topology.parent(leaf_bottom).identifier) # make a subtree of everything from the parent on down
			node_newParent = tree_topology.parent(node_upThree).identifier # identify past the double negative (3 x 1's)
			tree_topology.remove_node(node_upThree) # remove everything below the double negative
			tree_topology.paste(node_newParent, tree_sub_t) # and paste tree_sub_t onto the new location
		else:
			self.refine_topology(tree_topology.remove_node(leaf_bottom),node_upOne)	

	
		return tree_topology



